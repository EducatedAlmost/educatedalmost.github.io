<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Clojure's rarer threading macros: some-> and cond-> | blog.AlmostEducated</title>
<meta name=keywords content="clojure,java,lisp,programming,software patterns">
<meta name=description content="I use Clojure's threading macros perhaps more than I should, but I do so because they mimic the way I think about the code I write. A lisp programme is a tree and yet most of the programmes that we write are, or should be, lines of functions acting on a datastructure1 2.
The value of threading macros  1 2  (* 3 (+ 2 (- 10 (+ 10 (/ 2 2))))) ^     To grok this code I have to start from the bottommost leaf, in this case (/ 2 2), yet it is at the line's far right contrary to where it is natural for me and most of the world3 to start reading.">
<meta name=author content="AlmostEducated">
<link rel=canonical href=http://blog.almost.education/posts/clojure-threading-macros/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.58a033c0c7916fad77c5dfdffb45992d585075aa3bd3fd9fed09e7daf663c82b.css integrity="sha256-WKAzwMeRb613xd/f+0WZLVhQdao70/2f7Qnn2vZjyCs=" rel="preload stylesheet" as=style>
<link rel=preload href=/img/ae-logo-trans.png as=image>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.f5a1b978a132c6aeb40625c357309394e91f4bd93496f86730204de5630b035b.js integrity="sha256-9aG5eKEyxq60BiXDVzCTlOkfS9k0lvhnMCBN5WMLA1s=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://blog.almost.education/img/ae-logo-trans.png>
<link rel=icon type=image/png sizes=16x16 href=http://blog.almost.education/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://blog.almost.education/favicon-32x32.png>
<link rel=apple-touch-icon href=http://blog.almost.education/img/ae-logo-trans.png>
<link rel=mask-icon href=http://blog.almost.education/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=default"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-15THDLZMKJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-15THDLZMKJ',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Clojure's rarer threading macros: some-> and cond->">
<meta property="og:description" content="I use Clojure's threading macros perhaps more than I should, but I do so because they mimic the way I think about the code I write. A lisp programme is a tree and yet most of the programmes that we write are, or should be, lines of functions acting on a datastructure1 2.
The value of threading macros  1 2  (* 3 (+ 2 (- 10 (+ 10 (/ 2 2))))) ^     To grok this code I have to start from the bottommost leaf, in this case (/ 2 2), yet it is at the line's far right contrary to where it is natural for me and most of the world3 to start reading.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://blog.almost.education/posts/clojure-threading-macros/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-12-09T19:43:18+00:00">
<meta property="article:modified_time" content="2021-12-09T19:43:18+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Clojure's rarer threading macros: some-> and cond->">
<meta name=twitter:description content="I use Clojure's threading macros perhaps more than I should, but I do so because they mimic the way I think about the code I write. A lisp programme is a tree and yet most of the programmes that we write are, or should be, lines of functions acting on a datastructure1 2.
The value of threading macros  1 2  (* 3 (+ 2 (- 10 (+ 10 (/ 2 2))))) ^     To grok this code I have to start from the bottommost leaf, in this case (/ 2 2), yet it is at the line's far right contrary to where it is natural for me and most of the world3 to start reading.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://blog.almost.education/posts/"},{"@type":"ListItem","position":3,"name":"Clojure's rarer threading macros: some-\u003e and cond-\u003e","item":"http://blog.almost.education/posts/clojure-threading-macros/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Clojure's rarer threading macros: some- and cond-","name":"Clojure\u0027s rarer threading macros: some- and cond-","description":"I use Clojure\u0026#39;s threading macros perhaps more than I should, but I do so because they mimic the way I think about the code I write. A lisp programme is a tree and yet most of the programmes that we write are, or should be, lines of functions acting on a datastructure1 2.\nThe value of threading macros  1 2  (* 3 (+ 2 (- 10 (+ 10 (/ 2 2))))) ^     To grok this code I have to start from the bottommost leaf, in this case (/ 2 2), yet it is at the line\u0026#39;s far right contrary to where it is natural for me and most of the world3 to start reading.","keywords":["clojure","java","lisp","programming","software patterns"],"articleBody":"  I use Clojure's threading macros perhaps more than I should, but I do so because they mimic the way I think about the code I write. A lisp programme is a tree and yet most of the programmes that we write are, or should be, lines of functions acting on a datastructure1 2.\nThe value of threading macros  1 2  (* 3 (+ 2 (- 10 (+ 10 (/ 2 2))))) ^     To grok this code I have to start from the bottommost leaf, in this case (/ 2 2), yet it is at the line's far right contrary to where it is natural for me and most of the world3 to start reading. Conversely the same code written with a threading macro mirrors how we think about what the code is doing.\n1 2  (- 2 (/ 2) (+ 10) (- 10) (+ 2) (* 3)) ^     They also force the programmer into writing simpler code because threading macros don't handle trees well.\n1 2 3 4 5 6  (- 2 (/ 2) (+ 10) (- (- 25 (/ 5) (* 2))) (+ 2) (* 3))     What a mess. It's much better to split it into two linear forms.\n1 2 3  ;; Better do this (let [x (- 25 (/ 5) (* 2))] (- 2 (/ 2) (+ 10) (- x) (+ 2) (* 3)))     So threading macros help make easy things simple and complex things hard4.\n  as-   as- allows one to use a symbol to specify where the threaded value goes in each form. It is helpful when the threaded value's position in the function's arguments changes. Some Clojure functions take the datastructure as the first argument, others take a function.\n1 2 3  (as- (db/get id) $ (update $ :foo f x y) (map g $))      some-   some- works similarly to -, except that evaluation of the form terminates as soon as the threaded value becomes nil. It's named for some? which only returns false if its argument is nil. It is, generally, unnecessary in Clojure. Why? Because Clojure's core functions, and the functions that we write, gracefully handle nil.\n1 2 3 4 5 6 7  (map + nil) ; = () (assoc nil :k :v) ; = {:k :v} (dissoc nil :k) ; = nil (str nil) ; = \"\" (+ nil) ; = nil (- nil) ; = NullPointerException, ; it's not always the case     The same cannot be said for calling functions in Java. Try adding a value to a null HashMap, or .toString on a null object, and you'll throw a NullPointerException.\n1 2 3 4 5 6 7 8 9  (- id db/find-by-id (.put \"foo\" \"bar\") db/save) (- id db/find-by-id (assoc :id id \"foo\" \"bar\") db/save)     If db/find-by-id returns nil, implying a missing entity, the first form will explode when it tries to .put on a null object. The second gracefully creates and saves a new entity. If we still need to deal with the Java method, we can do so by either wrapping the form in a try form, or use some-.\n1 2 3 4 5 6  (if-some [save-result (some- id db/find-by-id (.put \"foo\" \"bar\") db/save)] (handle-success save-result) (handle-missing-entity id))     if-some is just like if-let, except instead of the test failing for falsy values, it fails for nil values. Equivalently, the test passes for (some? test) instead of (true? test).\n When db/find-by-id returns nil, some- immediately returns nil without evaluating the remaining forms of the threading macro, .put and db/save. if-some then handles the case of a missing entity. Otherwise, as long as db/save returns any non-nil value, it is bound to save-result and (handle-success save-result) will be called, even if the result is false.\n  cond-   I have found cond-, named for cond, to be the biggest code-saver out of any of Clojure's rarer standard library functions. Again, I use it mostly when working with Java, specifically with Builders. A Builder is one of the most common patterns you will see in object-oriented languages, it works to progressively build up an object, allowing for each field to have a default value, set fields by more convoluted means5, or verify fields before they are set6.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class EnterpriseIntegrator { private String foo; private String bar; private String qux; private String quux; public EnterpriseIntegrator ( String foo, String bar, String qux, String quux) { // ...  }; public newBuilder () { return new EnterpriseIntegratorBuilder(); } } public class EnterpriseIntegratorBuilder { private String foo = \"foo\"; private String bar = \"bar\"; private String qux = \"qux\"; private String quux = \"quux\"; public EnterpriseIntegratorBuilder foo (String foo) { this.foo = foo; return this; } // ...  public EnterpriseIntegrator build () { return new EnterpriseIntegrator ( this.foo, this.bar, this.qux, this.quux); } }     Of course, if this was Clojure we could just do this:\n1 2 3  (def defaults {:foo \"foo\" :bar \"bar\" :qux \"qux\" :quux \"quux\"}) (merge defaults {:foo \"foobar\" :bar \"baz\"}) ;; = {:foo \"foobar\" :bar \"baz\" :qux \"qux\" :quux \"quux\"}     But occasionally we will need to use a Java-style Builder.\n1 2 3 4 5  (- (new EnterpriseIntegratorBuilder) (.foo f) (.bar b) (.qux q) (.quux qu))     This blows up in ones face if this code get called by someone who wants to use the default value and doesn't want to set foo. In that case f is nil and a NullPointerException is thrown. cond- is a threading macro that allows us to only evaluate a form if a predicate returns true, and can be used to avoid this style of error.\n1 2 3 4  (cond- x (pred-1 f) (.foo \"foo\") (pred-2 b) (.bar \"bar\") (pred-3 q) (.qux \"qux\"))     If the predicate returns true, the next form is used as it would be in -. Unlike some-, if a predicate fails the macro doesn't terminate, it just moves onto the next predicate.\n If (pred-2 b) is the only predicate to fail, it becomes equivalent to this:\n1 2 3  (- x (.foo \"foo\") (.qux \"qux\"))     We can use this to check that a variable is non-nil before trying to set the field on the Builder.\n1 2 3 4 5 6  (defn -EnterpriseIntegrator [{:keys [foo bar baz]}] (cond- (new EnterpriseIntegrator) (some? foo) (.foo foo) (some? bar) (.bar bar) (some? baz) (.baz baz) true (.build)))     And finally we call build to return the EnterpriseIntegrator.\n  Other macros   -, some-, and cond- each have a matching macro, -, some-, and cond-, which inserts the threaded value as the last argument in each form. I don't find them often to be of much use.\n You can see Clojure's official guide on the subject here.\n  1 \"It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.\" — Alan Perlis, Epigrams on Programming\n  2 The Language of the System by Rich Hickey, Conj 2012. Having abandoned object-oriented languages, don't recreate them in the large by building a system of components that look like objects. Instead, choose to structure your system like you structure your functional programmes, pipelines of functions.\n  3 The major exceptions being Arabic, Hebrew, and Urdu.\n  4 https://en.wikipedia.org/wiki/Chiasmus\n  5 1 2 3 4 5  public EnterpriseIntegratorBuilder setCredentials (Credentials creds) { this.username = creds.getUsername(); this.password = creds.getPassword(); return this; }      6 1 2 3 4 5 6  public EnterpriseIntegratorBuilder setTimeoutMillis (int to) { if (to  0) { this.timeoutMillis = to; } // else one can use the default value or throw an exception  return this; }        ","wordCount":"1279","inLanguage":"en","datePublished":"2021-12-09T19:43:18Z","dateModified":"2021-12-09T19:43:18Z","author":{"@type":"Person","name":"AlmostEducated"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.almost.education/posts/clojure-threading-macros/"},"publisher":{"@type":"Organization","name":"blog.AlmostEducated","logo":{"@type":"ImageObject","url":"http://blog.almost.education/img/ae-logo-trans.png"}}}</script>
</head>
<body class=dark id=top>
<script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://blog.almost.education accesskey=h title="blog.AlmostEducated (Alt + H)">
<img src=/img/ae-logo-trans.png alt=logo aria-label=logo height=" 30px">blog.AlmostEducated</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://blog.almost.education/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://blog.almost.education/index.xml title=rss>
<span>rss</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Clojure's rarer threading macros: some-> and cond->
</h1>
<div class=post-meta>2021—12—09 Thu&nbsp;·&nbsp;AlmostEducated
</div>
<ul class=post-tags>
<li><a href=http://blog.almost.education/tags/clojure/>clojure</a></li>
<li><a href=http://blog.almost.education/tags/java/>java</a></li>
<li><a href=http://blog.almost.education/tags/lisp/>lisp</a></li>
<li><a href=http://blog.almost.education/tags/programming/>programming</a></li>
<li><a href=http://blog.almost.education/tags/software-patterns/>software patterns</a></li>
</ul>
</header>
<div class=post-content>
<p>
I use Clojure's threading macros perhaps more than I should, but I do so because they mimic the way I think about the code I write. A lisp programme is a tree and yet most of the programmes that we write are, or should be, lines of functions acting on a datastructure<sup class=footnote-reference><a id=footnote-reference-1 href=#footnote-1>1</a></sup> <sup class=footnote-reference><a id=footnote-reference-2 href=#footnote-2>2</a></sup>.</p>
<div id=outline-container-headline-1 class=outline-2>
<h2 id=headline-1>
The value of threading macros
</h2>
<div id=outline-text-headline-1 class=outline-text-2>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>* </span><span class=mi>3</span> <span class=p>(</span><span class=nb>+ </span><span class=mi>2</span> <span class=p>(</span><span class=nb>- </span><span class=mi>10</span> <span class=p>(</span><span class=nb>+ </span><span class=mi>10</span> <span class=p>(</span><span class=nb>/ </span><span class=mi>2</span> <span class=mi>2</span><span class=p>)))))</span>
                         <span class=o>^</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
To grok this code I have to start from the bottommost leaf, in this case <code>(/ 2 2)</code>, yet it is at the line's far right contrary to where it is natural for me and most of the world<sup class=footnote-reference><a id=footnote-reference-3 href=#footnote-3>3</a></sup> to start reading. Conversely the same code written with a threading macro mirrors how we think about what the code is doing.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>-&gt; </span><span class=mi>2</span> <span class=p>(</span><span class=nb>/ </span><span class=mi>2</span><span class=p>)</span> <span class=p>(</span><span class=nb>+ </span><span class=mi>10</span><span class=p>)</span> <span class=p>(</span><span class=nb>- </span><span class=mi>10</span><span class=p>)</span> <span class=p>(</span><span class=nb>+ </span><span class=mi>2</span><span class=p>)</span> <span class=p>(</span><span class=nb>* </span><span class=mi>3</span><span class=p>))</span>
    <span class=o>^</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
They also force the programmer into writing <em>simpler</em> code because threading macros don't handle trees well.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>-&gt; </span><span class=mi>2</span>
    <span class=p>(</span><span class=nb>/ </span><span class=mi>2</span><span class=p>)</span>
    <span class=p>(</span><span class=nb>+ </span><span class=mi>10</span><span class=p>)</span>
    <span class=p>(</span><span class=nb>- </span><span class=p>(</span><span class=nb>-&gt; </span><span class=mi>25</span> <span class=p>(</span><span class=nb>/ </span><span class=mi>5</span><span class=p>)</span> <span class=p>(</span><span class=nb>* </span><span class=mi>2</span><span class=p>)))</span>
    <span class=p>(</span><span class=nb>+ </span><span class=mi>2</span><span class=p>)</span>
    <span class=p>(</span><span class=nb>* </span><span class=mi>3</span><span class=p>))</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
What a mess. It's much better to split it into two linear forms.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=c1>;; Better do this</span>
<span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>x</span> <span class=p>(</span><span class=nb>-&gt; </span><span class=mi>25</span> <span class=p>(</span><span class=nb>/ </span><span class=mi>5</span><span class=p>)</span> <span class=p>(</span><span class=nb>* </span><span class=mi>2</span><span class=p>))]</span>
  <span class=p>(</span><span class=nb>-&gt; </span><span class=mi>2</span> <span class=p>(</span><span class=nb>/ </span><span class=mi>2</span><span class=p>)</span> <span class=p>(</span><span class=nb>+ </span><span class=mi>10</span><span class=p>)</span> <span class=p>(</span><span class=nb>- </span><span class=nv>x</span><span class=p>)</span> <span class=p>(</span><span class=nb>+ </span><span class=mi>2</span><span class=p>)</span> <span class=p>(</span><span class=nb>* </span><span class=mi>3</span><span class=p>)))</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
So threading macros help make easy things simple and complex things hard<sup class=footnote-reference><a id=footnote-reference-4 href=#footnote-4>4</a></sup>.</p>
</div>
</div>
<div id=outline-container-headline-2 class=outline-2>
<h2 id=headline-2>
<code>as-></code>
</h2>
<div id=outline-text-headline-2 class=outline-text-2>
<p>
<a href=https://clojuredocs.org/clojure.core/as-%3E><code>as-></code></a> allows one to use a symbol to specify where the threaded value goes in each form. It is helpful when the threaded value's position in the function's arguments changes. Some Clojure functions take the datastructure as the first argument, others take a function.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>as-&gt;</span> <span class=p>(</span><span class=nf>db/get</span> <span class=nv>id</span><span class=p>)</span> <span class=nv>$</span>
  <span class=p>(</span><span class=nf>update</span> <span class=nv>$</span> <span class=ss>:foo</span> <span class=nv>f</span> <span class=nv>x</span> <span class=nv>y</span><span class=p>)</span>
  <span class=p>(</span><span class=nb>map </span><span class=nv>g</span> <span class=nv>$</span><span class=p>))</span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id=outline-container-headline-3 class=outline-2>
<h2 id=headline-3>
<code>some-></code>
</h2>
<div id=outline-text-headline-3 class=outline-text-2>
<p>
<a href=https://clojuredocs.org/clojure.core/some-%3E><code>some-></code></a> works similarly to <code>-></code>, except that evaluation of the form terminates as soon as the threaded value becomes <code>nil</code>. It's named for <a href=https://clojuredocs.org/clojure.core/some_q><code>some?</code></a> which only returns <code>false</code> if its argument is <code>nil</code>. It is, generally, unnecessary in Clojure. Why? Because Clojure's core functions, and the functions that we write, gracefully handle <code>nil</code>.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>map + </span><span class=nv>nil</span><span class=p>)</span> <span class=c1>; =&gt; ()</span>
<span class=p>(</span><span class=nb>assoc </span><span class=nv>nil</span> <span class=ss>:k</span> <span class=ss>:v</span><span class=p>)</span> <span class=c1>; =&gt; {:k :v}</span>
<span class=p>(</span><span class=nb>dissoc </span><span class=nv>nil</span> <span class=ss>:k</span><span class=p>)</span> <span class=c1>; =&gt; nil</span>
<span class=p>(</span><span class=nb>str </span><span class=nv>nil</span><span class=p>)</span> <span class=c1>; =&gt; &#34;&#34;</span>
<span class=p>(</span><span class=nb>+ </span><span class=nv>nil</span><span class=p>)</span> <span class=c1>; =&gt; nil</span>
<span class=p>(</span><span class=nb>- </span><span class=nv>nil</span><span class=p>)</span> <span class=c1>; =&gt; NullPointerException,</span>
        <span class=c1>; it&#39;s not always the case</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
The same cannot be said for calling functions in Java. Try adding a value to a null <code>HashMap</code>, or <code>.toString</code> on a null object, and you'll throw a <code>NullPointerException</code>.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>-&gt; </span><span class=nv>id</span>
    <span class=nv>db/find-by-id</span>
    <span class=p>(</span><span class=nf>.put</span> <span class=s>&#34;foo&#34;</span> <span class=s>&#34;bar&#34;</span><span class=p>)</span>
    <span class=nv>db/save</span><span class=p>)</span>

<span class=p>(</span><span class=nb>-&gt; </span><span class=nv>id</span>
    <span class=nv>db/find-by-id</span>
    <span class=p>(</span><span class=nb>assoc </span><span class=ss>:id</span> <span class=nv>id</span> <span class=s>&#34;foo&#34;</span> <span class=s>&#34;bar&#34;</span><span class=p>)</span>
    <span class=nv>db/save</span><span class=p>)</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
If <code>db/find-by-id</code> returns <code>nil</code>, implying a missing entity, the first form will explode when it tries to <code>.put</code> on a <code>null</code> object. The second gracefully creates and saves a new entity. If we still need to deal with the Java method, we can do so by either wrapping the form in a <code>try</code> form, or use <code>some-></code>.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>if-some</span> <span class=p>[</span><span class=nv>save-result</span> <span class=p>(</span><span class=nf>some-&gt;</span> <span class=nv>id</span>
                              <span class=nv>db/find-by-id</span>
                              <span class=p>(</span><span class=nf>.put</span> <span class=s>&#34;foo&#34;</span> <span class=s>&#34;bar&#34;</span><span class=p>)</span>
                              <span class=nv>db/save</span><span class=p>)]</span>
  <span class=p>(</span><span class=nf>handle-success</span> <span class=nv>save-result</span><span class=p>)</span>
  <span class=p>(</span><span class=nf>handle-missing-entity</span> <span class=nv>id</span><span class=p>))</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
<code>if-some</code> is just like <code>if-let</code>, except instead of the test failing for falsy values, it fails for <code>nil</code> values. Equivalently, the test passes for <code>(some? test)</code> instead of <code>(true? test)</code>.</p>
<p>
When <code>db/find-by-id</code> returns <code>nil</code>, <code>some-></code> immediately returns <code>nil</code> without evaluating the remaining forms of the threading macro, <code>.put</code> and <code>db/save</code>. <code>if-some</code> then handles the case of a missing entity. Otherwise, as long as <code>db/save</code> returns any non-<code>nil</code> value, it is bound to <code>save-result</code> and <code>(handle-success save-result)</code> will be called, even if the result is <code>false</code>.</p>
</div>
</div>
<div id=outline-container-headline-4 class=outline-2>
<h2 id=headline-4>
<code>cond-></code>
</h2>
<div id=outline-text-headline-4 class=outline-text-2>
<p>
I have found <a href=https://clojuredocs.org/clojure.core/cond-%3E><code>cond-></code></a>, named for <a href=https://clojuredocs.org/clojure.core/cond><code>cond</code></a>, to be the biggest code-saver out of any of Clojure's rarer standard library functions. Again, I use it mostly when working with Java, specifically with Builders. A Builder is one of the most common patterns you will see in object-oriented languages, it works to progressively build up an object, allowing for each field to have a default value, set fields by more convoluted means<sup class=footnote-reference><a id=footnote-reference-5 href=#footnote-5>5</a></sup>, or verify fields before they are set<sup class=footnote-reference><a id=footnote-reference-6 href=#footnote-6>6</a></sup>.</p>
<div class="src src-java">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>EnterpriseIntegrator</span> <span class=o>{</span>

    <span class=kd>private</span> <span class=n>String</span> <span class=n>foo</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>String</span> <span class=n>bar</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>String</span> <span class=n>qux</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>String</span> <span class=n>quux</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>EnterpriseIntegrator</span> <span class=o>(</span>
        <span class=n>String</span> <span class=n>foo</span><span class=o>,</span> <span class=n>String</span> <span class=n>bar</span><span class=o>,</span> <span class=n>String</span> <span class=n>qux</span><span class=o>,</span> <span class=n>String</span> <span class=n>quux</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// ...
</span><span class=c1></span>    <span class=o>};</span>

    <span class=kd>public</span> <span class=nf>newBuilder</span> <span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=k>new</span> <span class=n>EnterpriseIntegratorBuilder</span><span class=o>();</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>EnterpriseIntegratorBuilder</span> <span class=o>{</span>

    <span class=kd>private</span> <span class=n>String</span> <span class=n>foo</span> <span class=o>=</span> <span class=s>&#34;foo&#34;</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>String</span> <span class=n>bar</span> <span class=o>=</span> <span class=s>&#34;bar&#34;</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>String</span> <span class=n>qux</span> <span class=o>=</span> <span class=s>&#34;qux&#34;</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>String</span> <span class=n>quux</span> <span class=o>=</span> <span class=s>&#34;quux&#34;</span><span class=o>;</span>

    <span class=kd>public</span> <span class=n>EnterpriseIntegratorBuilder</span> <span class=nf>foo</span> <span class=o>(</span><span class=n>String</span> <span class=n>foo</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>foo</span> <span class=o>=</span> <span class=n>foo</span><span class=o>;</span>
        <span class=k>return</span> <span class=k>this</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=c1>// ...
</span><span class=c1></span>
    <span class=kd>public</span> <span class=n>EnterpriseIntegrator</span> <span class=nf>build</span> <span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=k>new</span> <span class=n>EnterpriseIntegrator</span> <span class=o>(</span>
            <span class=k>this</span><span class=o>.</span><span class=na>foo</span><span class=o>,</span> <span class=k>this</span><span class=o>.</span><span class=na>bar</span><span class=o>,</span> <span class=k>this</span><span class=o>.</span><span class=na>qux</span><span class=o>,</span> <span class=k>this</span><span class=o>.</span><span class=na>quux</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
Of course, if this was Clojure we could just do this:</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>defaults</span> <span class=p>{</span><span class=ss>:foo</span> <span class=s>&#34;foo&#34;</span> <span class=ss>:bar</span> <span class=s>&#34;bar&#34;</span> <span class=ss>:qux</span> <span class=s>&#34;qux&#34;</span> <span class=ss>:quux</span> <span class=s>&#34;quux&#34;</span><span class=p>})</span>
<span class=p>(</span><span class=nb>merge </span><span class=nv>defaults</span> <span class=p>{</span><span class=ss>:foo</span> <span class=s>&#34;foobar&#34;</span> <span class=ss>:bar</span> <span class=s>&#34;baz&#34;</span><span class=p>})</span>
<span class=c1>;; =&gt; {:foo &#34;foobar&#34; :bar &#34;baz&#34; :qux &#34;qux&#34; :quux &#34;quux&#34;}</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
But occasionally we will need to use a Java-style Builder.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>-&gt; </span><span class=p>(</span><span class=k>new </span><span class=nv>EnterpriseIntegratorBuilder</span><span class=p>)</span>
    <span class=p>(</span><span class=nf>.foo</span> <span class=nv>f</span><span class=p>)</span>
    <span class=p>(</span><span class=nf>.bar</span> <span class=nv>b</span><span class=p>)</span>
    <span class=p>(</span><span class=nf>.qux</span> <span class=nv>q</span><span class=p>)</span>
    <span class=p>(</span><span class=nf>.quux</span> <span class=nv>qu</span><span class=p>))</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
This blows up in ones face if this code get called by someone who wants to use the default value and doesn't want to set <code>foo</code>. In that case <code>f</code> is <code>nil</code> and a <code>NullPointerException</code> is thrown. <code>cond-></code> is a threading macro that allows us to only evaluate a form if a predicate returns true, and can be used to avoid this style of error.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>cond-&gt;</span> <span class=nv>x</span>
  <span class=p>(</span><span class=nf>pred-1</span> <span class=nv>f</span><span class=p>)</span> <span class=p>(</span><span class=nf>.foo</span> <span class=s>&#34;foo&#34;</span><span class=p>)</span>
  <span class=p>(</span><span class=nf>pred-2</span> <span class=nv>b</span><span class=p>)</span> <span class=p>(</span><span class=nf>.bar</span> <span class=s>&#34;bar&#34;</span><span class=p>)</span>
  <span class=p>(</span><span class=nf>pred-3</span> <span class=nv>q</span><span class=p>)</span> <span class=p>(</span><span class=nf>.qux</span> <span class=s>&#34;qux&#34;</span><span class=p>))</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
If the predicate returns true, the next form is used as it would be in <code>-></code>. Unlike <code>some-></code>, if a predicate fails the macro doesn't terminate, it just moves onto the next predicate.</p>
<p>
If <code>(pred-2 b)</code> is the only predicate to fail, it becomes equivalent to this:</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>-&gt; </span><span class=nv>x</span>
    <span class=p>(</span><span class=nf>.foo</span> <span class=s>&#34;foo&#34;</span><span class=p>)</span>
    <span class=p>(</span><span class=nf>.qux</span> <span class=s>&#34;qux&#34;</span><span class=p>))</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
We can use this to check that a variable is non-<code>nil</code> before trying to set the field on the Builder.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=kd>defn </span><span class=nv>-&gt;EnterpriseIntegrator</span> <span class=p>[{</span><span class=ss>:keys</span> <span class=p>[</span><span class=nv>foo</span> <span class=nv>bar</span> <span class=nv>baz</span><span class=p>]}]</span>
  <span class=p>(</span><span class=nf>cond-&gt;</span> <span class=p>(</span><span class=k>new </span><span class=nv>EnterpriseIntegrator</span><span class=p>)</span>
    <span class=p>(</span><span class=nf>some?</span> <span class=nv>foo</span><span class=p>)</span> <span class=p>(</span><span class=nf>.foo</span> <span class=nv>foo</span><span class=p>)</span>
    <span class=p>(</span><span class=nf>some?</span> <span class=nv>bar</span><span class=p>)</span> <span class=p>(</span><span class=nf>.bar</span> <span class=nv>bar</span><span class=p>)</span>
    <span class=p>(</span><span class=nf>some?</span> <span class=nv>baz</span><span class=p>)</span> <span class=p>(</span><span class=nf>.baz</span> <span class=nv>baz</span><span class=p>)</span>
    <span class=nv>true</span> <span class=p>(</span><span class=nf>.build</span><span class=p>)))</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
And finally we call <code>build</code> to return the <code>EnterpriseIntegrator</code>.</p>
</div>
</div>
<div id=outline-container-headline-5 class=outline-2>
<h2 id=headline-5>
Other macros
</h2>
<div id=outline-text-headline-5 class=outline-text-2>
<p>
<code>-></code>, <code>some-></code>, and <code>cond-></code> each have a matching macro, <code>->></code>, <code>some->></code>, and <code>cond->></code>, which inserts the threaded value as the last argument in each form. I don't find them often to be of much use.</p>
<p>
You can see Clojure's official guide on the subject <a href=https://clojure.org/guides/threading_macros>here</a>.</p>
</div>
</div>
<div class=footnotes>
<hr class=footnotes-separatator>
<div class=footnote-definitions>
<div class=footnote-definition>
<sup id=footnote-1><a href=#footnote-reference-1>1</a></sup>
<div class=footnote-body>
<p>"It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures." — Alan Perlis, <em>Epigrams on Programming</em></p>
</div>
</div>
<div class=footnote-definition>
<sup id=footnote-2><a href=#footnote-reference-2>2</a></sup>
<div class=footnote-body>
<p><a href="https://youtu.be/ROor6_NGIWU?t=1592">The Language of the System</a> by Rich Hickey, Conj 2012. Having abandoned object-oriented languages, don't recreate them in the large by building a system of components that look like objects. Instead, choose to structure your system like you structure your functional programmes, pipelines of functions.</p>
</div>
</div>
<div class=footnote-definition>
<sup id=footnote-3><a href=#footnote-reference-3>3</a></sup>
<div class=footnote-body>
<p>The major exceptions being Arabic, Hebrew, and Urdu.</p>
</div>
</div>
<div class=footnote-definition>
<sup id=footnote-4><a href=#footnote-reference-4>4</a></sup>
<div class=footnote-body>
<p><a href=https://en.wikipedia.org/wiki/Chiasmus>https://en.wikipedia.org/wiki/Chiasmus</a></p>
</div>
</div>
<div class=footnote-definition>
<sup id=footnote-5><a href=#footnote-reference-5>5</a></sup>
<div class=footnote-body>
<div class="src src-java">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=n>EnterpriseIntegratorBuilder</span> <span class=nf>setCredentials</span> <span class=o>(</span><span class=n>Credentials</span> <span class=n>creds</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>this</span><span class=o>.</span><span class=na>username</span> <span class=o>=</span> <span class=n>creds</span><span class=o>.</span><span class=na>getUsername</span><span class=o>();</span>
    <span class=k>this</span><span class=o>.</span><span class=na>password</span> <span class=o>=</span> <span class=n>creds</span><span class=o>.</span><span class=na>getPassword</span><span class=o>();</span>
    <span class=k>return</span> <span class=k>this</span><span class=o>;</span>
<span class=o>}</span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div class=footnote-definition>
<sup id=footnote-6><a href=#footnote-reference-6>6</a></sup>
<div class=footnote-body>
<div class="src src-java">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=n>EnterpriseIntegratorBuilder</span> <span class=nf>setTimeoutMillis</span> <span class=o>(</span><span class=kt>int</span> <span class=n>to</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>to</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>timeoutMillis</span> <span class=o>=</span> <span class=n>to</span><span class=o>;</span>
    <span class=o>}</span> <span class=c1>// else one can use the default value or throw an exception
</span><span class=c1></span>    <span class=k>return</span> <span class=k>this</span><span class=o>;</span>
<span class=o>}</span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://blog.almost.education/tags/clojure/>clojure</a></li>
<li><a href=http://blog.almost.education/tags/java/>java</a></li>
<li><a href=http://blog.almost.education/tags/lisp/>lisp</a></li>
<li><a href=http://blog.almost.education/tags/programming/>programming</a></li>
<li><a href=http://blog.almost.education/tags/software-patterns/>software patterns</a></li>
</ul>
</footer><div id=disqus_thread>
</div>
<script>(function(){var a=document,b=a.createElement('script');b.src='https://blog-almost-education.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script>
<noscript>
Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a>
</noscript>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://blog.almost.education>blog.AlmostEducated</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>