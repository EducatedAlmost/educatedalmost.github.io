<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Clojure CLI apps using GraalVM | blog.AlmostEducated</title>
<meta name=keywords content="clojure,jvm,cli,programming">
<meta name=description content="Clojure, like other JVM languages, excels in long-running tasks1. But I was always jealous of the languages that I'd used for scripting and command line tools which can't wait a second for a JVM to start for each invocation. Despite its slow startup time, the JVM shines at peak throughput. Some times we want one, sometimes the other. For tasks that have a very short lifetime (~1s), we need Ahead of Time compilation.">
<meta name=author content="AlmostEducated">
<link rel=canonical href=http://blog.almost.education/posts/clojure-cli-graal/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.58a033c0c7916fad77c5dfdffb45992d585075aa3bd3fd9fed09e7daf663c82b.css integrity="sha256-WKAzwMeRb613xd/f+0WZLVhQdao70/2f7Qnn2vZjyCs=" rel="preload stylesheet" as=style>
<link rel=preload href=/img/ae-logo-trans.png as=image>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.f5a1b978a132c6aeb40625c357309394e91f4bd93496f86730204de5630b035b.js integrity="sha256-9aG5eKEyxq60BiXDVzCTlOkfS9k0lvhnMCBN5WMLA1s=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://blog.almost.education/img/ae-logo-trans.png>
<link rel=icon type=image/png sizes=16x16 href=http://blog.almost.education/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://blog.almost.education/favicon-32x32.png>
<link rel=apple-touch-icon href=http://blog.almost.education/img/ae-logo-trans.png>
<link rel=mask-icon href=http://blog.almost.education/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=default"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-15THDLZMKJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-15THDLZMKJ',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Clojure CLI apps using GraalVM">
<meta property="og:description" content="Clojure, like other JVM languages, excels in long-running tasks1. But I was always jealous of the languages that I'd used for scripting and command line tools which can't wait a second for a JVM to start for each invocation. Despite its slow startup time, the JVM shines at peak throughput. Some times we want one, sometimes the other. For tasks that have a very short lifetime (~1s), we need Ahead of Time compilation.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://blog.almost.education/posts/clojure-cli-graal/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-12-14T18:28:42+00:00">
<meta property="article:modified_time" content="2021-12-14T18:28:42+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Clojure CLI apps using GraalVM">
<meta name=twitter:description content="Clojure, like other JVM languages, excels in long-running tasks1. But I was always jealous of the languages that I'd used for scripting and command line tools which can't wait a second for a JVM to start for each invocation. Despite its slow startup time, the JVM shines at peak throughput. Some times we want one, sometimes the other. For tasks that have a very short lifetime (~1s), we need Ahead of Time compilation.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://blog.almost.education/posts/"},{"@type":"ListItem","position":3,"name":"Clojure CLI apps using GraalVM","item":"http://blog.almost.education/posts/clojure-cli-graal/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Clojure CLI apps using GraalVM","name":"Clojure CLI apps using GraalVM","description":"Clojure, like other JVM languages, excels in long-running tasks1. But I was always jealous of the languages that I\u0026#39;d used for scripting and command line tools which can\u0026#39;t wait a second for a JVM to start for each invocation. Despite its slow startup time, the JVM shines at peak throughput. Some times we want one, sometimes the other. For tasks that have a very short lifetime (~1s), we need Ahead of Time compilation.","keywords":["clojure","jvm","cli","programming"],"articleBody":"  Clojure, like other JVM languages, excels in long-running tasks1. But I was always jealous of the languages that I'd used for scripting and command line tools which can't wait a second for a JVM to start for each invocation. Despite its slow startup time, the JVM shines at peak throughput. Some times we want one, sometimes the other. For tasks that have a very short lifetime (~1s), we need Ahead of Time compilation.\nAOT vs. JIT   Whatever happens, the code you write is translated to machine code that is executed on the host machine. One might think that, when compiling C, this is a single step, but it is a process from preprocessor to compiler to assembler and then linker. At the end of this, all of the machine code has been produced before the programme is run.\nJIT   Not so with Java and JVM languages. When one 'compiles' a JVM project, say by calling javac, one produces bytecode — not machine code. When the programme is run and the JVM is started, the JVM does the work of compiling its bytecode into machine code on an ad hoc basis as methods are called, hence the name just-in-time compilation2.\n JIT has its benefits. It can make optimisations because it knows exactly the machine it is compiling for, whereas with C the build machine will likely be different from the machine the code runs on. The JVM also has the ability to profile the code as it runs and make optimisations based on how the code is actually used. Say in the code there is are references to foo.bar(false, n) and foo.bar(true, n) but as the code is run the latter is called millions of times more often than the former. JIT compilation can see this and optimise calls to foo.bar where the first argument is true. This is the sort of information that is not available when compiling beforehand.\n  AOT   Perhaps, by now, you have guessed that the alternative is ahead-of-time compilation. Compiling ahead of time, there is no need for a JVM to run, and thus no profiling and no ad hoc compilation. The result is a programme that starts instantly and with a much smaller memory footprint (~×10).\n For two decades, there was no other way to run JVM languages except on the JVM by way of JIT. But now, with the release of GraalVM in 2019, we can now compile our JVM programmes via AOT, straight to machine code.\n    GraalVM   GraalVM, from the Old French graal meaning grail, is an Oracle project comprising:\n GraalVM Compiler, a JIT compiler for Java GraalVM Native Image, a AOT compiler for Java Truffle Language Implementation Framework, a specification for running other languages on GraalVM LLVM and Javascript runtimes  We're interested in the AOT compiler. First we need a copy of GraalVM; go to https://www.graalvm.org/downloads/ and download the appropriate package, or if using Arch one install it from the AUR.\n From wherever you install external binaries (/usr/bin, ~/bin), extract the archive and set its location as an environment variable:\n1 2  tar -xzvf ~/dl/graalvm-ce-java11-linux-amd64-21.3.0.tar.gz export GRAALVM_HOME=~/bin/graalvm-ce-java11-21.3.0     This might not add Graal's executables to your PATH, but they can be run using $GRAALVM_HOME/bin/... etc.. If you encounter permissions issues, you might have to run chmod +x  for the file to be able to be executed.\nHello Graal   I keep all my source code in ~/src, make changes to the commands for your system. These commands create a new Clojure project.\n1 2 3  mkdir -p ~/src/hello-graal/src/hello_graal cd ~/src/hello-graal touch ./src/hello_graal/main.clj     And in main.clj create this very simple Hello World application.\n1 2 3 4 5  (ns hello-graal.main (:gen-class)) (defn -main [\u0026 _args] (println \"Hello Graal!\"))     We can use Clojure's compile to compile the namespace into classfiles, as one would with javac. The bytecode in the classfiles would normally be used by the JVM, but we will use them with Graal's native-image to produce an executable binary. Graal doesn't explicitly support Clojure, but once Clojure is compiled to bytecode it is just the same as any other JVM language, including Java.\n1 2  mkdir classes clojure -M -e \"(compile 'hello-graal.main)\"     We can write a script, compile, that contains the call to Graal's native-image.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #!/usr/bin/env bash  if [ -z \"$GRAALVM_HOME\" ]; then echo 'Please set GRAALVM_HOME' exit 1 fi mkdir classes clojure -M -e \"(compile 'hello-graal.main)\" # Ensure Graal native-image program is installed \"$GRAALVM_HOME/bin/gu\" install native-image \"$GRAALVM_HOME/bin/native-image\" \\  -cp \"$(clojure -Spath):classes\" \\  -H:Name=hello-graal \\  -H:+ReportExceptionStackTraces \\  --initialize-at-build-time \\  --verbose \\  --no-fallback \\  --no-server \\  \"-J-Xmx3g\" \\  hello_graal.main     When this script is run it produces an executable, hello-graal. Give it a try!\n1 2 3  chmod +x compile ./compile ./hello-graal      Next steps   This is a subject I'd like to return to. I see great promise for the role of Clojure in creating native applications. Graal's already being used by Babashka, clojure-lsp, and clj-kondo, three tools I use on a daily basis.\n Our next steps might be to add the ability to add command-line options and arguments using tools.cli. And we can read from stdin using (new java.io.BufferedReader *in*).\n1 2 3 4 5 6 7 8 9 10 11  (ns hello-graal.main (:require [clojure.tools.cli :as cli])) (def cli-options [[\"-v\" \"--verbose\" \"Verbosity\"]]) (defn -main [\u0026 args] (let [opts (cli/parse-opts args cli-options)] (doseq [ln (line-seq (new java.io.BufferedReader *in*))] ;; Use a line from input. )))     In part two I will show how to replicate some of the functionality of clj-kondo, and then implement some missing features.\n    1 Maximising Java Application Performance with GraalVM by Oleg Šelajev at GOTO 2020.\n  2  The earliest possible mention of JIT I know of is from John McCarthy of Lisp fame:\n The programmer may have selected S-functions compiled into machine language programs put into the core memory. Values of compiled functions are computed about 60 times as fast as they would if interpreted. Compilation is fast enough so that it is not necessary to punch compiled program for future use.\n — Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I, 1960\n Instead, we suspect that the earliest published work on JIT compilation was McCarthy’s [1960] LISP paper. He men- tioned compilation of functions into ma- chine language, a process fast enough that the compiler’s output needn’t be saved. This can be seen as an inevitable result of having programs and data share the same notation [McCarthy 1981].\n — John Aycock, 2003\n    ","wordCount":"1084","inLanguage":"en","datePublished":"2021-12-14T18:28:42Z","dateModified":"2021-12-14T18:28:42Z","author":{"@type":"Person","name":"AlmostEducated"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.almost.education/posts/clojure-cli-graal/"},"publisher":{"@type":"Organization","name":"blog.AlmostEducated","logo":{"@type":"ImageObject","url":"http://blog.almost.education/img/ae-logo-trans.png"}}}</script>
</head>
<body class=dark id=top>
<script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://blog.almost.education accesskey=h title="blog.AlmostEducated (Alt + H)">
<img src=/img/ae-logo-trans.png alt=logo aria-label=logo height=" 30px">blog.AlmostEducated</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://blog.almost.education/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://blog.almost.education/index.xml title=rss>
<span>rss</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Clojure CLI apps using GraalVM
</h1>
<div class=post-meta>2021—12—14 Tue&nbsp;·&nbsp;AlmostEducated
</div>
<ul class=post-tags>
<li><a href=http://blog.almost.education/tags/clojure/>clojure</a></li>
<li><a href=http://blog.almost.education/tags/jvm/>jvm</a></li>
<li><a href=http://blog.almost.education/tags/cli/>cli</a></li>
<li><a href=http://blog.almost.education/tags/programming/>programming</a></li>
</ul>
</header>
<div class=post-content>
<p>
Clojure, like other JVM languages, excels in long-running tasks<sup class=footnote-reference><a id=footnote-reference-1 href=#footnote-1>1</a></sup>. But I was always jealous of the languages that I'd used for scripting and command line tools which can't wait a second for a JVM to start for each invocation. Despite its slow startup time, the JVM shines at peak throughput. Some times we want one, sometimes the other. For tasks that have a very short lifetime (~1s), we need Ahead of Time compilation.</p>
<div id=outline-container-headline-1 class=outline-2>
<h2 id=headline-1>
AOT vs. JIT
</h2>
<div id=outline-text-headline-1 class=outline-text-2>
<p>
Whatever happens, the code you write is translated to machine code that is executed on the host machine. One might think that, when compiling C, this is a single step, but it is a process from preprocessor to compiler to assembler and then linker. At the end of this, all of the machine code has been produced before the programme is run.</p>
<div id=outline-container-headline-2 class=outline-3>
<h3 id=headline-2>
JIT
</h3>
<div id=outline-text-headline-2 class=outline-text-3>
<p>
Not so with Java and JVM languages. When one '<em>compiles</em>' a JVM project, say by calling <code>javac</code>, one produces bytecode — not machine code. When the programme is run and the JVM is started, the JVM does the work of compiling its bytecode into machine code on an <em>ad hoc</em> basis as methods are called, hence the name <em>just-in-time</em> compilation<sup class=footnote-reference><a id=footnote-reference-2 href=#footnote-2>2</a></sup>.</p>
<p>
JIT has its benefits. It can make optimisations because it knows exactly the machine it is compiling for, whereas with C the build machine will likely be different from the machine the code runs on. The JVM also has the ability to profile the code as it runs and make optimisations based on how the code is actually used. Say in the code there is are references to <code>foo.bar(false, n)</code> and <code>foo.bar(true, n)</code> but as the code is run the latter is called millions of times more often than the former. JIT compilation can see this and optimise calls to <code>foo.bar</code> where the first argument is <code>true</code>. This is the sort of information that is not available when compiling beforehand.</p>
</div>
</div>
<div id=outline-container-headline-3 class=outline-3>
<h3 id=headline-3>
AOT
</h3>
<div id=outline-text-headline-3 class=outline-text-3>
<p>
Perhaps, by now, you have guessed that the alternative is <em>ahead-of-time</em> compilation. Compiling ahead of time, there is no need for a JVM to run, and thus no profiling and no <em>ad hoc</em> compilation. The result is a programme that starts instantly and with a <em>much</em> smaller memory footprint (~×10).</p>
<p>
For two decades, there was no other way to run JVM languages except on the JVM by way of JIT. But now, with the release of <a href=https://www.graalvm.org/>GraalVM</a> in 2019, we can now compile our JVM programmes via AOT, straight to machine code.</p>
</div>
</div>
</div>
</div>
<div id=outline-container-headline-4 class=outline-2>
<h2 id=headline-4>
GraalVM
</h2>
<div id=outline-text-headline-4 class=outline-text-2>
<p>
GraalVM, from the Old French <em>graal</em> meaning <em>grail</em>, is an Oracle project comprising:</p>
<ul>
<li>GraalVM Compiler, a JIT compiler for Java</li>
<li>GraalVM Native Image, a AOT compiler for Java</li>
<li>Truffle Language Implementation Framework, a specification for running other languages on GraalVM</li>
<li>LLVM and Javascript runtimes</li>
</ul>
<p>We're interested in the AOT compiler. First we need a copy of GraalVM; go to <a href=https://www.graalvm.org/downloads/>https://www.graalvm.org/downloads/</a> and download the appropriate package, or if using Arch one install it from the <a href=https://aur.archlinux.org/packages/native-image-jdk11-bin/>AUR</a>.</p>
<p>
From wherever you install external binaries (<code>/usr/bin</code>, <code>~/bin</code>), extract the archive and set its location as an environment variable:</p>
<div class="src src-text">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-text data-lang=text>tar -xzvf ~/dl/graalvm-ce-java11-linux-amd64-21.3.0.tar.gz
export GRAALVM_HOME=~/bin/graalvm-ce-java11-21.3.0</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
This might not add Graal's executables to your PATH, but they can be run using <code>$GRAALVM_HOME/bin/...</code> etc.. If you encounter permissions issues, you might have to run <code>chmod +x &lt;executable></code> for the file to be able to be executed.</p>
<div id=outline-container-headline-5 class=outline-3>
<h3 id=headline-5>
<em>Hello Graal</em>
</h3>
<div id=outline-text-headline-5 class=outline-text-3>
<p>
I keep all my source code in <code>~/src</code>, make changes to the commands for your system. These commands create a new Clojure project.</p>
<div class="src src-bash">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>mkdir -p ~/src/hello-graal/src/hello_graal
<span class=nb>cd</span> ~/src/hello-graal
touch ./src/hello_graal/main.clj</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
And in <code>main.clj</code> create this very simple <em>Hello World</em> application.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=kd>ns </span><span class=nv>hello-graal.main</span>
  <span class=p>(</span><span class=ss>:gen-class</span><span class=p>))</span>

<span class=p>(</span><span class=kd>defn </span><span class=nv>-main</span> <span class=p>[</span><span class=o>&amp;</span> <span class=nv>_args</span><span class=p>]</span>
  <span class=p>(</span><span class=nb>println </span><span class=s>&#34;Hello Graal!&#34;</span><span class=p>))</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
We can use Clojure's <code>compile</code> to compile the namespace into classfiles, as one would with <code>javac</code>. The bytecode in the classfiles would normally be used by the JVM, but we will use them with Graal's <code>native-image</code> to produce an executable binary. Graal doesn't explicitly support Clojure, but once Clojure is compiled to bytecode it is just the same as any other JVM language, including Java.</p>
<div class="src src-text">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-text data-lang=text>mkdir classes
clojure -M -e &#34;(compile &#39;hello-graal.main)&#34;</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
We can write a script, <code>compile</code>, that contains the call to Graal's <code>native-image</code>.</p>
<div class="src src-bash">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/usr/bin/env bash
</span><span class=cp></span>
<span class=k>if</span> <span class=o>[</span> -z <span class=s2>&#34;</span><span class=nv>$GRAALVM_HOME</span><span class=s2>&#34;</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
    <span class=nb>echo</span> <span class=s1>&#39;Please set GRAALVM_HOME&#39;</span>
    <span class=nb>exit</span> <span class=m>1</span>
<span class=k>fi</span>

mkdir classes
clojure -M -e <span class=s2>&#34;(compile &#39;hello-graal.main)&#34;</span>

<span class=c1># Ensure Graal native-image program is installed</span>
<span class=s2>&#34;</span><span class=nv>$GRAALVM_HOME</span><span class=s2>/bin/gu&#34;</span> install native-image

<span class=s2>&#34;</span><span class=nv>$GRAALVM_HOME</span><span class=s2>/bin/native-image&#34;</span> <span class=se>\
</span><span class=se></span>    -cp <span class=s2>&#34;</span><span class=k>$(</span>clojure -Spath<span class=k>)</span><span class=s2>:classes&#34;</span> <span class=se>\
</span><span class=se></span>    -H:Name<span class=o>=</span>hello-graal <span class=se>\
</span><span class=se></span>    -H:+ReportExceptionStackTraces <span class=se>\
</span><span class=se></span>    --initialize-at-build-time  <span class=se>\
</span><span class=se></span>    --verbose <span class=se>\
</span><span class=se></span>    --no-fallback <span class=se>\
</span><span class=se></span>    --no-server <span class=se>\
</span><span class=se></span>    <span class=s2>&#34;-J-Xmx3g&#34;</span> <span class=se>\
</span><span class=se></span>    hello_graal.main</code></pre></td></tr></table>
</div>
</div>
</div>
<p>
When this script is run it produces an executable, <code>hello-graal</code>. Give it a try!</p>
<div class="src src-text">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-text data-lang=text>chmod +x compile
./compile
./hello-graal</code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id=outline-container-headline-6 class=outline-3>
<h3 id=headline-6>
Next steps
</h3>
<div id=outline-text-headline-6 class=outline-text-3>
<p>
This is a subject I'd like to return to. I see great promise for the role of Clojure in creating native applications. Graal's already being used by <a href=https://github.com/babashka/babashka>Babashka</a>, <a href=https://github.com/clojure-lsp/clojure-lsp>clojure-lsp</a>, and <a href=https://github.com/clj-kondo/clj-kondo>clj-kondo</a>, three tools I use on a daily basis.</p>
<p>
Our next steps might be to add the ability to add command-line options and arguments using <a href=https://github.com/clojure/tools.cli>tools.cli</a>. And we can read from <code>stdin</code> using <code>(new java.io.BufferedReader *in*)</code>.</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=kd>ns </span><span class=nv>hello-graal.main</span>
  <span class=p>(</span><span class=ss>:require</span> <span class=p>[</span><span class=nv>clojure.tools.cli</span> <span class=ss>:as</span> <span class=nv>cli</span><span class=p>]))</span>

<span class=p>(</span><span class=k>def </span><span class=nv>cli-options</span>
  <span class=p>[[</span><span class=s>&#34;-v&#34;</span> <span class=s>&#34;--verbose&#34;</span> <span class=s>&#34;Verbosity&#34;</span><span class=p>]])</span>

<span class=p>(</span><span class=kd>defn </span><span class=nv>-main</span> <span class=p>[</span><span class=o>&amp;</span> <span class=nv>args</span><span class=p>]</span>
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>opts</span> <span class=p>(</span><span class=nf>cli/parse-opts</span> <span class=nv>args</span> <span class=nv>cli-options</span><span class=p>)]</span>
    <span class=p>(</span><span class=nb>doseq </span><span class=p>[</span><span class=nv>ln</span> <span class=p>(</span><span class=nb>line-seq </span><span class=p>(</span><span class=k>new </span><span class=nv>java.io.BufferedReader</span> <span class=nv>*in*</span><span class=p>))]</span>
      <span class=c1>;; Use a line from input.</span>
      <span class=p>)))</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
In part two I will show how to replicate some of the functionality of clj-kondo, and then implement some missing features.</p>
</div>
</div>
</div>
</div>
<div class=footnotes>
<hr class=footnotes-separatator>
<div class=footnote-definitions>
<div class=footnote-definition>
<sup id=footnote-1><a href=#footnote-reference-1>1</a></sup>
<div class=footnote-body>
<p><a href="https://www.youtube.com/watch?v=PeMvksAZbdw&t=647s">Maximising Java Application Performance with GraalVM</a> by Oleg Šelajev at GOTO 2020.</p>
</div>
</div>
<div class=footnote-definition>
<sup id=footnote-2><a href=#footnote-reference-2>2</a></sup>
<div class=footnote-body>
<p>
The earliest possible mention of JIT I know of is from John McCarthy of Lisp fame:</p>
<blockquote>
<p>The programmer may have selected S-functions compiled into machine
language programs put into the core memory. Values of compiled functions
are computed about 60 times as fast as they would if interpreted. Compilation
is fast enough so that it is not necessary to punch compiled program for future
use.</p>
</blockquote>
<p>— <a href=http://www-formal.stanford.edu/jmc/recursive.pdf>Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I, 1960</a></p>
<blockquote>
<p>Instead, we suspect that the earliest published work on JIT compilation was McCarthy’s [1960] LISP paper. He men- tioned compilation of functions into ma- chine language, a process fast enough that the compiler’s output needn’t be saved. This can be seen as an inevitable result of having programs and data share the same notation [McCarthy 1981].</p>
</blockquote>
<p>— <a href=https://www.eecs.ucf.edu/~dcm/Teaching/COT4810-Spring2011/Literature/JustInTimeCompilation.pdf>John Aycock, 2003</a></p>
</div>
</div>
</div>
</div>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://blog.almost.education/tags/clojure/>clojure</a></li>
<li><a href=http://blog.almost.education/tags/jvm/>jvm</a></li>
<li><a href=http://blog.almost.education/tags/cli/>cli</a></li>
<li><a href=http://blog.almost.education/tags/programming/>programming</a></li>
</ul>
</footer><div id=disqus_thread>
</div>
<script>(function(){var a=document,b=a.createElement('script');b.src='https://blog-almost-education.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script>
<noscript>
Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a>
</noscript>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://blog.almost.education>blog.AlmostEducated</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>