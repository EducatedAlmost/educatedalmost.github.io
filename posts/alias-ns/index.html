<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>æ/alias+ns | blog.AlmostEducated</title>
<meta name=keywords content="clojure,programming">
<meta name=description content="Macros that makes namespace aliases easy.
 https://github.com/EducatedAlmost/alias-ns.git
 Qualified keywords have ballooned in popularity since the release of spec with Clojure 1.9. And thankfully so! A creed amongst Clojurians is that maps should be open to modification, meaning that I should be able to add data to a map without worrying that it will break its consumer, and that when processing maps we shouldn't remove data using something like select-keys without good reason.">
<meta name=author content="AlmostEducated">
<link rel=canonical href=http://blog.almost.education/posts/alias-ns/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.58a033c0c7916fad77c5dfdffb45992d585075aa3bd3fd9fed09e7daf663c82b.css integrity="sha256-WKAzwMeRb613xd/f+0WZLVhQdao70/2f7Qnn2vZjyCs=" rel="preload stylesheet" as=style>
<link rel=preload href=/img/ae-logo-trans.png as=image>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.f5a1b978a132c6aeb40625c357309394e91f4bd93496f86730204de5630b035b.js integrity="sha256-9aG5eKEyxq60BiXDVzCTlOkfS9k0lvhnMCBN5WMLA1s=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://blog.almost.education/img/ae-logo-trans.png>
<link rel=icon type=image/png sizes=16x16 href=http://blog.almost.education/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://blog.almost.education/favicon-32x32.png>
<link rel=apple-touch-icon href=http://blog.almost.education/img/ae-logo-trans.png>
<link rel=mask-icon href=http://blog.almost.education/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=default"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-15THDLZMKJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-15THDLZMKJ',{anonymize_ip:!1})}</script>
<meta property="og:title" content="æ/alias+ns">
<meta property="og:description" content="Macros that makes namespace aliases easy.
 https://github.com/EducatedAlmost/alias-ns.git
 Qualified keywords have ballooned in popularity since the release of spec with Clojure 1.9. And thankfully so! A creed amongst Clojurians is that maps should be open to modification, meaning that I should be able to add data to a map without worrying that it will break its consumer, and that when processing maps we shouldn't remove data using something like select-keys without good reason.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://blog.almost.education/posts/alias-ns/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-11-24T13:30:06+00:00">
<meta property="article:modified_time" content="2021-11-24T13:30:06+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="æ/alias+ns">
<meta name=twitter:description content="Macros that makes namespace aliases easy.
 https://github.com/EducatedAlmost/alias-ns.git
 Qualified keywords have ballooned in popularity since the release of spec with Clojure 1.9. And thankfully so! A creed amongst Clojurians is that maps should be open to modification, meaning that I should be able to add data to a map without worrying that it will break its consumer, and that when processing maps we shouldn't remove data using something like select-keys without good reason.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://blog.almost.education/posts/"},{"@type":"ListItem","position":3,"name":"æ/alias+ns","item":"http://blog.almost.education/posts/alias-ns/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"æ/alias+ns","name":"æ\/alias\u002bns","description":"Macros that makes namespace aliases easy.\n https://github.com/EducatedAlmost/alias-ns.git\n Qualified keywords have ballooned in popularity since the release of spec with Clojure 1.9. And thankfully so! A creed amongst Clojurians is that maps should be open to modification, meaning that I should be able to add data to a map without worrying that it will break its consumer, and that when processing maps we shouldn\u0026#39;t remove data using something like select-keys without good reason.","keywords":["clojure","programming"],"articleBody":" Macros that makes namespace aliases easy.\n https://github.com/EducatedAlmost/alias-ns.git\n Qualified keywords have ballooned in popularity since the release of spec with Clojure 1.9. And thankfully so! A creed amongst Clojurians is that maps should be open to modification, meaning that I should be able to add data to a map without worrying that it will break its consumer, and that when processing maps we shouldn't remove data using something like select-keys without good reason.\n But there was a problem that occasionally (assoc m k v) would be destructive — because we were all using the same keys. Every application seemingly has its own :id, :user, :service, :credentials; and associng a new one would dissoc the previous and break whoever was waiting to consume it. With the introduction of qualified keywords, I can instead assoc :ae.bespoke/id without fear.\n Qualified, sometimes called namespaced, keywords abound in my code. For larger projects there might be up to ten namespaces to which a keyword belongs, think: :ae.bespoke.user/id, :ae.bespoke.item/id, :ae.bespoke.process/id. And Clojure allows us to use aliases, most commonly defined within (ns ... (:require [ae.bespoke.user :as user])), so the keywords can be shrunk to just ::user/id.\n I only very occasionally have a problem with this, here's an example. You start developing your application in ae.bespoke.core, but decide to split user functionality into ae.bespoke.user. This works well until you want to reference a user's id in core, and try ::user/id as you do in many of your other source files. It fails because core doesn't require user, and if it did you would have a circular dependency because user itself requires core.\n What are the alternatives? Use :ae.bespoke.user/id instead of ::user/id. This is what I would recommend most of the time, but it has the principal drawback that when referencing this key throughout our code we must always be thinking about whether the current namespace depends upon the user namespace.\n To aleviate this aspect of cognitive load, I have created alias+ns. It's a macro that allows one to alias a namespace that has not been required in the current namespace. So in ae.bespoke.user, this would be valid:\n1 2  (alias+ns 'user 'ae.bespoke.user) {::user/id 356}     And if using many aliases, use aliases+ns:\n1 2 3 4 5 6  (aliases+ns {'user 'ae.bespoke.user 'item 'ae.bespoke.item 'process 'ae.bespoke.process}) {::user/id 356 ::item/id 9134 ::process/id 22}     You can do all this without the worry of circular dependencies. Just don't try to define functions or variables in the aliased namespace, or maybe do but I haven't a clue what would happen.\n I won't be arrogant and claim that this is the best thing to do in all cases, or even that it is best in most cases; but I have found it to be very useful in projects with large numbers of namespaces, where it also reduces the pain of refactoring when code moves between them. I hope you find a use for it too.\n","wordCount":"480","inLanguage":"en","datePublished":"2021-11-24T13:30:06Z","dateModified":"2021-11-24T13:30:06Z","author":{"@type":"Person","name":"AlmostEducated"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.almost.education/posts/alias-ns/"},"publisher":{"@type":"Organization","name":"blog.AlmostEducated","logo":{"@type":"ImageObject","url":"http://blog.almost.education/img/ae-logo-trans.png"}}}</script>
</head>
<body class=dark id=top>
<script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://blog.almost.education accesskey=h title="blog.AlmostEducated (Alt + H)">
<img src=/img/ae-logo-trans.png alt=logo aria-label=logo height=" 30px">blog.AlmostEducated</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://blog.almost.education/tags/ title=tags>
<span>tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
æ/alias+ns
</h1>
<div class=post-meta>2021—11—24 Wed&nbsp;·&nbsp;AlmostEducated
</div>
<ul class=post-tags>
<li><a href=http://blog.almost.education/tags/clojure/>clojure</a></li>
<li><a href=http://blog.almost.education/tags/programming/>programming</a></li>
</ul>
</header>
<div class=post-content><p>
<em>Macros that makes namespace aliases easy.</em></p>
<p>
<a href=https://github.com/EducatedAlmost/alias-ns.git>https://github.com/EducatedAlmost/alias-ns.git</a></p>
<p>
Qualified keywords have ballooned in popularity since the release of spec with Clojure 1.9. And thankfully so! A creed amongst Clojurians is that maps should be open to modification, meaning that I should be able to add data to a map without worrying that it will break its consumer, and that when processing maps we shouldn't remove data using something like <code>select-keys</code> without good reason.</p>
<p>
But there was a problem that occasionally <code>(assoc m k v)</code> would be destructive — because we were all using the same keys. Every application seemingly has its own <code>:id</code>, <code>:user</code>, <code>:service</code>, <code>:credentials</code>; and associng a new one would dissoc the previous and break whoever was waiting to consume it. With the introduction of qualified keywords, I can instead assoc <code>:ae.bespoke/id</code> without fear.</p>
<p>
Qualified, sometimes called namespaced, keywords abound in my code. For larger projects there might be up to ten namespaces to which a keyword belongs, think: <code>:ae.bespoke.user/id</code>, <code>:ae.bespoke.item/id</code>, <code>:ae.bespoke.process/id</code>. And Clojure allows us to use aliases, most commonly defined within <code>(ns ... (:require [ae.bespoke.user :as user]))</code>, so the keywords can be shrunk to just <code>::user/id</code>.</p>
<p>
I only very occasionally have a problem with this, here's an example. You start developing your application in <code>ae.bespoke.core</code>, but decide to split user functionality into <code>ae.bespoke.user</code>. This works well until you want to reference a user's id in <code>core</code>, and try <code>::user/id</code> as you do in many of your other source files. It fails because <code>core</code> doesn't require <code>user</code>, and if it did you would have a circular dependency because <code>user</code> itself requires <code>core</code>.</p>
<p>
What are the alternatives? Use <code>:ae.bespoke.user/id</code> instead of <code>::user/id</code>. This is what I would recommend most of the time, but it has the principal drawback that when referencing this key throughout our code we must always be thinking about whether the current namespace depends upon the user namespace.</p>
<p>
To aleviate this aspect of cognitive load, I have created <code>alias+ns</code>. It's a macro that allows one to alias a namespace that has not been required in the current namespace. So in <code>ae.bespoke.user</code>, this would be valid:</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>alias+ns</span> <span class=ss>&#39;user</span> <span class=ss>&#39;ae.bespoke.user</span><span class=p>)</span>
<span class=p>{</span><span class=ss>::user/id</span> <span class=mi>356</span><span class=p>}</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
And if using many aliases, use <code>aliases+ns</code>:</p>
<div class="src src-clojure">
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>aliases+ns</span> <span class=p>{</span><span class=ss>&#39;user</span>    <span class=ss>&#39;ae.bespoke.user</span>
             <span class=ss>&#39;item</span>    <span class=ss>&#39;ae.bespoke.item</span>
             <span class=ss>&#39;process</span> <span class=ss>&#39;ae.bespoke.process</span><span class=p>})</span>
<span class=p>{</span><span class=ss>::user/id</span> <span class=mi>356</span>
 <span class=ss>::item/id</span> <span class=mi>9134</span>
 <span class=ss>::process/id</span> <span class=mi>22</span><span class=p>}</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
You can do all this without the worry of circular dependencies. Just don't try to define functions or variables in the aliased namespace, or maybe do but I haven't a clue what would happen.</p>
<p>
I won't be arrogant and claim that this is the best thing to do in all cases, or even that it is best in most cases; but I have found it to be very useful in projects with large numbers of namespaces, where it also reduces the pain of refactoring when code moves between them. I hope you find a use for it too.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://blog.almost.education/tags/clojure/>clojure</a></li>
<li><a href=http://blog.almost.education/tags/programming/>programming</a></li>
</ul>
</footer><div id=disqus_thread>
</div>
<script>(function(){var a=document,b=a.createElement('script');b.src='https://blog-almost-education.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script>
<noscript>
Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a>
</noscript>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://blog.almost.education>blog.AlmostEducated</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>