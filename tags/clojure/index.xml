<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>clojure on blog.AlmostEducated</title><link>http://blog.almost.education/tags/clojure/</link><description>Recent content in clojure on blog.AlmostEducated</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Thu, 09 Dec 2021 19:43:18 +0000</lastBuildDate><atom:link href="http://blog.almost.education/tags/clojure/index.xml" rel="self" type="application/rss+xml"/><item><title>Clojure's rarer threading macros: some-> and cond-></title><link>http://blog.almost.education/posts/clojure-threading-macros/</link><pubDate>Thu, 09 Dec 2021 19:43:18 +0000</pubDate><guid>http://blog.almost.education/posts/clojure-threading-macros/</guid><description>I use Clojure&amp;#39;s threading macros perhaps more than I should, but I do so because they mimic the way I think about the code I write. A lisp programme is a tree and yet most of the programmes that we write are, or should be, lines of functions acting on a datastructure1 2.
The value of threading macros 1 2 (* 3 (+ 2 (- 10 (+ 10 (/ 2 2))))) ^ To grok this code I have to start from the bottommost leaf, in this case (/ 2 2), yet it is at the line&amp;#39;s far right contrary to where it is natural for me and most of the world3 to start reading.</description></item><item><title>An 8-year-old Clojure bug, resorting to Java</title><link>http://blog.almost.education/posts/clojure-java-bug/</link><pubDate>Wed, 08 Dec 2021 15:26:12 +0000</pubDate><guid>http://blog.almost.education/posts/clojure-java-bug/</guid><description>Dodge a Clojure bug by using Java and tools.build</description></item><item><title>æ/alias+ns</title><link>http://blog.almost.education/posts/alias-ns/</link><pubDate>Wed, 24 Nov 2021 13:30:06 +0000</pubDate><guid>http://blog.almost.education/posts/alias-ns/</guid><description>Macros that makes namespace aliases easy.
https://github.com/EducatedAlmost/alias-ns.git
Qualified keywords have ballooned in popularity since the release of spec with Clojure 1.9. And thankfully so! A creed amongst Clojurians is that maps should be open to modification, meaning that I should be able to add data to a map without worrying that it will break its consumer, and that when processing maps we shouldn&amp;#39;t remove data using something like select-keys without good reason.</description></item><item><title>æ/Rashomon</title><link>http://blog.almost.education/posts/rashomon/</link><pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate><guid>http://blog.almost.education/posts/rashomon/</guid><description>See things from another perspective; Clojure functions that build datastructures from events.</description></item><item><title>æ/Demesne</title><link>http://blog.almost.education/posts/demesne/</link><pubDate>Wed, 17 Nov 2021 00:00:00 +0000</pubDate><guid>http://blog.almost.education/posts/demesne/</guid><description>You don&amp;#39;t understand a pattern until you can implement it — domain-driven design, CQRS, event sourcing.</description></item></channel></rss>