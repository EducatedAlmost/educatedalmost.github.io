<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>lisp on blog.AlmostEducated</title><link>http://blog.almost.education/tags/lisp/</link><description>Recent content in lisp on blog.AlmostEducated</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Thu, 09 Dec 2021 19:43:18 +0000</lastBuildDate><atom:link href="http://blog.almost.education/tags/lisp/index.xml" rel="self" type="application/rss+xml"/><item><title>Clojure's rarer threading macros: some-> and cond-></title><link>http://blog.almost.education/posts/clojure-threading-macros/</link><pubDate>Thu, 09 Dec 2021 19:43:18 +0000</pubDate><guid>http://blog.almost.education/posts/clojure-threading-macros/</guid><description>I use Clojure&amp;#39;s threading macros perhaps more than I should, but I do so because they mimic the way I think about the code I write. A lisp programme is a tree and yet most of the programmes that we write are, or should be, lines of functions acting on a datastructure1 2.
The value of threading macros 1 2 (* 3 (+ 2 (- 10 (+ 10 (/ 2 2))))) ^ To grok this code I have to start from the bottommost leaf, in this case (/ 2 2), yet it is at the line&amp;#39;s far right contrary to where it is natural for me and most of the world3 to start reading.</description></item></channel></rss>