<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>cli on blog.AlmostEducated</title><link>http://blog.almost.education/tags/cli/</link><description>Recent content in cli on blog.AlmostEducated</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Tue, 14 Dec 2021 18:28:42 +0000</lastBuildDate><atom:link href="http://blog.almost.education/tags/cli/index.xml" rel="self" type="application/rss+xml"/><item><title>Clojure CLI apps using GraalVM</title><link>http://blog.almost.education/posts/clojure-cli-graal/</link><pubDate>Tue, 14 Dec 2021 18:28:42 +0000</pubDate><guid>http://blog.almost.education/posts/clojure-cli-graal/</guid><description>Clojure, like other JVM languages, excels in long-running tasks1. But I was always jealous of the languages that I&amp;#39;d used for scripting and command line tools which can&amp;#39;t wait a second for a JVM to start for each invocation. Despite its slow startup time, the JVM shines at peak throughput. Some times we want one, sometimes the other. For tasks that have a very short lifetime (~1s), we need Ahead of Time compilation.</description></item></channel></rss>